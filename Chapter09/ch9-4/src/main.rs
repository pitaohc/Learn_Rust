use std::net::IpAddr;

fn main() {
    /*
    错误处理原则
    使用panic的情况：代替用户决定如何处理错误的情况
    使用Result的情况：用户决定如何处理错误的情况
    */

    /*
    使用panic的场景：
    - 演示某些概念: unwrap
    - 原型代码: unwrap, expect
    - 测试: unwrap, expect
    */

    /*
    有时我们比编译器掌握更多的信息
    - 确定Result就是Ok：unwrap
    */
    let home:IpAddr = "127.0.0.1".parse().unwrap(); //一定是Ok

    /*
    错误处理的指导性建议
    当代码最终可能处于损坏状态时，最好使用panic
    损坏状态(bad state)：当某些不符合预期的事情发生时，程序处于一种无法处理的状态
    - 例如：非法的值、矛盾的值、空缺的值被传入代码
    - 以下条件之一：
        - 这种损坏状态并不是预期能够偶尔发生的
        - 在此之后，代码如果处于这种损坏状态就无法运行
        - 当前使用的类型中没有一个好的方法编码这些处于损坏状态的信息
    */
    /*
    场景建议
    - 调用代码传入无意义的值: panic
    - 调用外部不可控的代码，返回非法状态，无法修复: panic
    - 当代码操作某些值，首先应该验证这些值: panic
    - 失败是可以预期的: Result
    */

    /*
    为验证使用自定义类型
    */
}
