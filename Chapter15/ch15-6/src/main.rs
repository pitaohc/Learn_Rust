/*
内部可变性
允许只持有不可变引用的情况下修改数据
数据结构中使用了unsafe代码绕过Rust正常的可变性和借用规则
*/

/*
RefCell<T>
RefCell<T>代表了其持有数据的唯一所有权，与Rc<T>不同

RefCell<T>与Box<T>的区别
Box<T>在编译阶段强制代码遵守借用规则
否则出现编译错误
RefCell<T>在运行时检查借用规则
否则会panic
*/
/*
借用规则在不同阶段检查的比较

编译阶段：
- 尽早暴露问题
- 没有运行时开销
- 对大多数场景是最佳选择
- Rust默认行为

运行时：
- 问题暴露延后，甚至到生产环境
- 因借用计数产生运行时开销
- 实现某些特定的内存安全场景（不可变环境中修改自身数据）
*/

/*
RefCell<T>只能用于单线程场景
*/

/*
             | Box<T>           | Rc<T>           | RefCell<T>
数据所有者个数 | 1                | 多个             | 1
可变性        | 可变、不可变借用   | 不可变借用        | 可变、不可变借用
借用检查      | 编译阶段          | 编译阶段          | 运行时
RefCell<T>本身不可变，但仍能修改内部存储的值
*/

/*
内部可变性：可变的借用一个不可变的值
*/
fn example_1(){
    let x = 5;
    // let y = &mutx; // error,不可变的值被可变的借用
}
/*
使用RefCell<T>在运行时检查借用规则
两个方法：
- borrow
    返回智能指针Ref<T>
- borrow_mut
    返回智能指针RefMut<T>
使用RefCell<T>时会记录当前有多少个活动的Ref<T>和RefMut<T>智能指针
*/
/*
其他实现内部可变性的类型
Cell<T> 通过复制来访问数据
Mutex<T> 用于多线程
*/
fn main() {
    println!("Hello, world!");
}
